using System;

namespace методы
{
    class Program
    //если метод не имеет тип void то он возвращает определенное нам значение
    {
        static void Main(string[] args)//если перед методом стоит тип void, то метод не будет ничего возвращать
        /* основной у нас метод это метот Main,поэтому,чтобы вызвать работу других методов то мы должны обратиться к ним через метод main*/

        {
            Metod1();//чообы обратиться к методу,нам просто нужно ввессти его имя
            //при этом метод вызывается при условии,что модификаторы будут одинаковы как у метода main and Metod1(static)
            //если использовать методы с разными подификаторами,то будет ошибка, как с методом Metod2
            string s = Hello();//мы можем в основном методе задать значение переменной,которая будет принимать значение,которое будет получать метод
            Console.WriteLine(s);


            int z = Sum();
            Console.WriteLine(z);


            int l = Umnog(10, 5);//в данные скобки мы ввожим значения,которые нам нужны
            Console.WriteLine(l);

            //в значение переменной мы можем ввести и сои значения
            int m = 50;
            int j = 20;

            int n = Umnog2(m, j);//в данные скобки мы ввожим значения,которые нам нужны
            //при этом мы можнем передавать один и тот же метод несколько раз,и каждый раз менять ему значение
            n = Umnog2(6, 6);
            Console.WriteLine(n);
            //последующие строки кода используются,чтобы показать,что метод без ref не меняет значение переменной,а исп. ее копию,
            //а метод с ref использует ссылку на данную переменную и меняет ее(указывает на одну и туже область памяти)
            int e = 100;
            int r = 100;
            Console.WriteLine($"after e={e}");
            Avoidafter(e, r);
            Console.WriteLine($"after Avoidafter e={e}");
            Avoidref(ref e, r);
            Console.WriteLine($"after Avoidref e= {e}");
            //можем так же задать значение переменным,но те переменные которые стоят после out точно должны иметь типы
            int we;
            int qw;
            Optional(10, 5, out we, out qw);
            Console.WriteLine($"pirimetr{we}");
            Console.WriteLine($"area{qw}");
            //необязательный метод:
            //в первом примере мы задали сами значение параметрам z3,z4,поэтому их значения в методе не будут использоваться
            int x1 = lox(1, 2, 3, 4);
            //во втором случае мы не задали значение переменной z4,поэтому оно будет браться из метода z4=6
            int x2 = lox(1, 2, 3);
            //в третьем случае мы не указали значение для двух переменных,поэтому они будут браться из метода
            int x3 = lox(1, 2);
            Console.WriteLine(x1);
            Console.WriteLine(x2);
            Console.WriteLine(x3);
            /* так же мы можем задавать значение переменных в независимости от порядка в методе, выглядит эт так:
             * int c1=lox(z2:2,z4:1,z1:6,z3:0);*/
            Console.ReadKey();

        }
        static void Metod1()
        {
            Console.WriteLine("Metod1");

        }
        void Metod2()
        {
            Console.WriteLine("Metod2");
        }
        static string Hello()//данный метод имеет тип string,поэтому такой метод могут называть функцией
                             //данный метод возвращает нужное нам значение,но именно слова
        {
            return "HEllo world";
        }
        static int Sum()
        {
            int x = 59;
            int y = 69;
            return x + y;
        }
        //чтобы вводить любые значения,которые мы хотим,нам надо ввести в скобки(полсе названия метода)параметры
        static int Umnog(int k, int c)//тип параметра должен соответствовать типу значения переменной
        {
            return k * c;
        }
        static int Umnog2(int v, int b)//тип параметра должен соответствовать типу значения переменной
        {
            return v * b;
        }
        //обычно метод использует копию значения переменной,которую мы задаем сами
        // но тип ref использует ссылку на эту переменную и меняет ее примеры
        static void Avoidafter(int q, int w)
        {
            q = q + w;
            Console.WriteLine($"Avoidafter" + q);

        }
        static void Avoidref(ref int q, int w)//когда ставится ref  в скобках после имени метода,то это значит,что берется и меняется тип заданной переменной
        {
            q = q + w;
            Console.WriteLine($"Avoidref" + q);
        }
        //обычно выходной параметр может выводить с помощью return одно значение,
        //но с добавлением к переменным out параметр может выводить от двох и более значений
        //слово return уходит и заменяется на значение переменной,которое мы указали после out
        static void Optional(int t, int u, out int pirimetr, out int area)
        {
            pirimetr = (t + u) * 2;
            area = t * u;

        }
        //необязательные параметры
        //мы в методе указываем значение параметра и если мы не будем его вы задавать в методе main,то это значение будет браться из
        //побочноного метода
        static int lox(int z1,int z2, int z3=5,int z4=6)
        {
            return z1 + z2 + z3 + z4;
        }




}
}
